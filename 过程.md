---
date: 2025-06-30
tags:
---
# 过程
- 过程提供了一种抽象方法，用一组指定的参数和一个可选的返回值实现某个过程。
- 过程P调用过程Q，Q执行后返回到P。
	1. 传递控制。
		- 进入过程Q时，PC被设置为过程Q的代码起始地址，返回时需要将PC设置为过程P调用过程Q的下一条指令的地址。
	2. 传递数据。
		- 过程P能向过程Q提供一个或多个参数，过程Q能向过程P返回一个值。
	3. 分配和释放内存。
		- 过程Q开始时，可能需要为局部变量分配空间，返回过程P时，需要释放该空间。
## 运行时栈
- 过程调用机制的关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。
- 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。
	- 该部分称为**栈帧**。
	- 当所有局部变量都能保存在寄存器中，且该函数不会调用任何其他函数。
		- 该函数称为**叶子过程**。
### 函数创建栈帧的条件
- 函数创建了局部变量。
- 函数调用了其他函数。
- 需要保存被调用者保存寄存器。
- 启用了调试符号（-g），或未启用 `-fomit-frame-pointer`时。
- 使用了变长数组，导致变长栈帧。
## 转移控制
- `call Q`将返回地址压入栈中，并将PC设置为`Q`的起始地址。
	- 可以直接调用，也可以间接调用。
	- 直接调用是一个标号，间接调用是`*`后跟一个操作数指示符。
- `ret`从栈中弹出返回地址，并设置PC。
### 过程调用指令
| 指令              | 描述       |
| --------------- | -------- |
| `call Label`    | 过程调用     |
| `call *Operand` | 过程调用     |
| `ret`           | 从过程调用中返回 |
| `leave;ret;`    | 恢复栈帧并返回。 |
- `leave;`等价于`push rbp;mov rbp,rsp`。若创建了栈帧则需要使用`leave;`恢复栈帧。
## 数据传送
- 参数传递时，必须要先将参数复制到寄存器中。
- x86-64中，寄存器最多传递6个整型参数。超过6个需要通过栈传递参数，**数据大小都向8的倍数对齐**。
- 寄存器中的数据，若是在函数调用后没有被使用，则不会将其备份到栈中。否则将其备份到栈或其他寄存器中。
- 寄存器传参从左到右，若寄存器不够，使用栈传参，则从右至左依次传参。
### 栈上的局部存储
- 局部数据必须存放在内容中的条件
	- 寄存器不足以存放所有数据。
	- 对一个局部变量使用地址运算符`&`，必须为其产生一个地址。
	- 某些局部变量是数组或结构，必须能够通过数组或结构引用被访问到。
	- 
### 特殊寄存器
|寄存器|调用约定类型|是否函数需要保留|
|---|---|---|
|`%rdi`, `%rsi`, `%rdx`|caller-saved|❌ 调用者负责保留|
|`%rbx`, `%rbp`, `%r12`|callee-saved|✅ 被调用者必须保留|-
- `%rbx`、`%rbp`、`%r12`在被调函数中只要被使用，在函数开始前就必须要将其压入栈中保存。
## System V ABI（x86-64）调用约定
> System V Application Binary Interface 是 Linux / Unix 平台 x86-64 架构下的标准函数调用约定，定义了函数调用、参数传递、返回值、寄存器使用等底层规则。
### 参数传递规则（整数/指针）
| 参数编号 | 使用的寄存器 |
|----------|---------------|
| 第1个参数 | `%rdi` |
| 第2个参数 | `%rsi` |
| 第3个参数 | `%rdx` |
| 第4个参数 | `%rcx` |
| 第5个参数 | `%r8`  |
| 第6个参数 | `%r9`  |
| 第7个及以后 | 通过 **栈** 从右向左传递（caller 压入） |
###  返回值传递
| 返回类型      | 使用的寄存器          |
| --------- | --------------- |
| 整型 / 指针   | `%rax`          |
| 浮点数       | `%xmm0`         |
| 结构体 / 大对象 | 通过隐藏的返回地址指针 + 栈 |
###  寄存器保存规则（Caller vs Callee）
#### Caller-Saved（调用者保存）
| 寄存器                                                  |
| ---------------------------------------------------- |
| `%rax`, `%rcx`, `%rdx`, `%rsi`, `%rdi`, `%r8`–`%r11` |
> 如果调用者还要使用这些寄存器，就 **必须在调用前保存副本**，因为调用函数可能会改写它们。
#### Callee-Saved（被调用者保存）
| 寄存器                           |
| ----------------------------- |
| `%rbx`, `%rbp`, `%r12`–`%r15` |
| `%xmm0`–`%xmm7`               |
> 被调用函数若使用这些寄存器，**必须先保存（如 `push`），并在返回前恢复（如 `pop`）**。
### 栈帧结构（Stack Frame Layout）
|栈帧|
|-|
|上一个函数的 %rbp 值|
|返回地址（call 后压入）|
|被保存的寄存器（如 %rbx）|
|局部变量 / 对齐空间|
### 栈对齐要求
- 函数调用前，**%rsp 必须是 16 字节对齐的**。
	- 低4比特必须为全0。
	- **调用函数前 `%rsp` 对齐**，否则传递浮点参数或调用变参函数（如 `printf`）可能出错。
	- 确保SIMD 指令安全。
	- 调试器下断点时刻栈尚未对齐。
- 通常函数开头这样做：
  ```asm
  push %rbp
  mov %rsp, %rbp
  sub $0x20, %rsp    ; 分配空间 & 对齐