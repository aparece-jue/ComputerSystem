---
date: 2025-06-30
tags:
---
# 控制
## 条件码
- 单个位存储，用于描述最近的算术和逻辑操作的属性。
- 可以通过检测其值来执行条件分支指令。
- 算数运算和逻辑运算会设置相应的条件标志位。
	- 按位逻辑操作时，`CF`与`OF`会被设置为`0`。
	- 移位操作时，`CF`会设置为最后一个被移出的位，`OF`设置为`0`。
	- `INC`和`DEC`会设置`OF`与`ZF`，但**不会改变`CF`**。
### 常见的条件码标志位
| 标志位    | 位号  | 名称                   | 含义                                        |
| ------ | --- | -------------------- | ----------------------------------------- |
| **CF** | 0   | Carry Flag（进位/借位标志）  | 加法运算有无进位／减法运算有无借位。                        |
| **PF** | 2   | Parity Flag（奇偶校验标志）  | 最低字节是否有偶数个`1`。                            |
| **AF** | 4   | Adjust Flag（半字节进位标志） | 对 BCD（packed decimal）运算有用，平常很少直接用         |
| **ZF** | 6   | Zero Flag（零标志）       | 运算结果是否为零。                                 |
| **SF** | 7   | Sign Flag（符号标志）      | 最高位（符号位）是否为`1`。                           |
| **TF** | 8   | Trap Flag（陷阱标志）      | 单步调试模式，每条指令执行后触发调试异常                      |
| **IF** | 9   | Interrupt Flag（中断标志） | 控制是否响应外部硬件中断（`CLI`/`STI` 设置清除）            |
| **DF** | 10  | Direction Flag（方向标志） | 字符串/块操作指令（`MOVS`/`CMPS`）是 “由高地址向低地址” 还是相反 |
| **OF** | 11  | Overflow Flag（溢出标志）  | 有符号运算是否溢出。                                |
### 常见的条件跳转
|跳转|测试条件|对应标志|
|---|---|---|
|`JO` / `JNO`|溢出 / 无溢出|`OF =1` / `OF =0`|
|`JB` / `JAE`|无符号 `<` / `>=`|`CF =1` / `CF =0`|
|`JE` / `JNE`|等于 / 不等于|`ZF =1` / `ZF =0`|
|`JBE` / `JA`|无符号 `<=` / `>`|`CF =1 ∨ ZF=1` / `CF=0 ∧ ZF=0`|
|`JS` / `JNS`|负 / 非负|`SF =1` / `SF =0`|
|`JP` / `JNP`|奇校验 / 偶校验|`PF =1` / `PF =0`|
|`JL` / `JGE`|有符号 `<` / `>=`|`SF ⊕ OF =1` / `SF⊕OF=0`|
|`JLE` / `JG`|有符号 `<=` / `>`|`ZF=1 ∨ SF⊕OF=1` / `ZF=0 ∧ SF⊕OF=0`|
## 设置条件码
| 指令                    | 原理          | 描述   |
| --------------------- | ----------- | ---- |
| $CMP \qquad S_1,S_2$  | $S_2 - S_1$ | 比较   |
| $cmpb$                |             | 比较字节 |
| $cmpw$                |             | 比较字  |
| $cmpl$                |             | 比较双字 |
| $cmpq$                |             | 比较四字 |
| $TEST \qquad S_1,S_2$ | $S_1\&S_2$  | 测试   |
| $testb$               |             | 测试字节 |
| $testw$               |             | 测试字  |
| $testl$               |             | 测试双字 |
| $testq$               |             | 测试四字 |
- `CMP`与`TEST`**只设置条件码而不改变任何其他寄存器**。
## 访问条件码
- 根据条件码的某种组合，将一个字节设置为`0`或`1`。
- 条件跳转到程序的某个其他的部分。
- 可以有条件地传送数据。
### SET指令
| 条件       | 指令              | 同义名      | 效果                                          | 含义                |
| -------- | --------------- | -------- | ------------------------------------------- | ----------------- |
| $CF = 1$ | $setc \quad D$  | $setb$   | $D \gets CF$                                | 无符号加法进位 / 无符号减法借位 |
| $CF = 0$ | $setnc \quad D$ | $setae$  | $D \gets  \sim CF$                          | 无符号无进位 / 无符号大于等于  |
| $ZF = 1$ | $setz \quad D$  | $sete$   | $D \gets ZF$                                | 结果为零              |
| $ZF = 0$ | $setnz \quad D$ | $setne$  | $D \gets  \sim ZF$                          | 结果非零              |
| $SF = 1$ | $sets \quad D$  | —        | $D \gets SF$                                | 结果负（最高位 1）        |
| $SF = 0$ | $setns \quad D$ | —        | $D \gets  \sim SF$                          | 结果非负（最高位 0）       |
| $OF = 1$ | $seto \quad D$  | —        | $D \gets OF$                                | 有符号运算溢出           |
| $OF = 0$ | $setno \quad D$ | —        | $D \gets  \sim OF$                          | 无溢出               |
| $PF = 1$ | $setp \quad D$  | $setpe$  | $D \gets PF$                                | 低 8 位有偶数个 1       |
| $PF = 0$ | $setnp \quad D$ | $setpo$  | $D \gets  \sim PF$                          | 低 8 位有奇数个 1       |
|          |                 |          |                                             |                   |
|          | $sete$          | $setz$   | $D \gets ZF$                                | $=$               |
|          | $setne$         | $setnz$  | $D \gets \sim ZF$                           | $\neq$            |
|          |                 |          |                                             |                   |
|          | $setb$          | $setnae$ | $D \gets CF$                                | 无符号 $<$           |
|          | $setbe$         | $setna$  | $D \gets CF \lor ZF$                        | 无符号 $\le$         |
|          | $seta$          | $setnbe$ | $D \gets \sim CF \land \sim ZF$             | 无符号 $>$           |
|          | $setae$         | $setnb$  | $D \gets \sim CF$                           | 无符号 $\ge$         |
|          |                 |          |                                             |                   |
|          | $setl$          | $setnge$ | $D \gets SF \oplus OF$                      | 有符号 $<$           |
|          | $setle$         | $setng$  | $D \gets (SF \oplus OF) \lor ZF$            | 有符号 $\le$         |
|          | $setg$          | $setnle$ | $D \gets \sim (SF \oplus OF) \land \sim ZF$ | 有符号 $>$           |
|          | $setge$         | $setnl$  | $D \gets \sim (SF \oplus OF)$               | 有符号 $\ge$         |
- $D$的目标操作数是低位单字节寄存器元素。
## 跳转
- 跳转的两种类型
	- **直接跳转**。
		- 跳转目标是作为指令的一部分编码的。给出一个标号作为跳转目标。
	- **间接跳转**。
		- 写法是`*`后跟一个操作数指示符。
- 跳转指令的编码方式。
	- 地址偏移量
		- 将目标指令的地址与**紧跟在跳转指令后面的那条指令的地址**之间的差作为编码。
			- 处理器执行指令前会优先更新PC计数器。
		- 可以编码为1、2、4字节。
	- 绝对地址。
		- 用四个字节直接指令目标。
### JMP指令
| 指令                  | 同义名    | 跳转条件                                | 描述         |
| ------------------- | ------ | ----------------------------------- | ---------- |
| $jmp \quad Label$   |        | $1$                                 | 直接跳转       |
| $jmp \quad * Label$ |        | $1$                                 | 间接跳转       |
|                     |        |                                     |            |
| $je \quad Label$    | $jz$   | $ZF$                                | 相等/零       |
| $jne \quad Label$   | $jnz$  | $\sim ZF$                           | 不等/非零      |
|                     |        |                                     |            |
| $js \quad Label$    |        | $SF$                                | 负数         |
| $jns \quad Label$   |        | $\sim SF$                           | 非负数        |
|                     |        |                                     |            |
| $jl \quad Label$    | $jnge$ | $SF \oplus OF$                      | 有符号数，$<$   |
| $jle \quad Label$   | $jng$  | $(SF \oplus OF) \lor ZF$            | 有符号数，$\le$ |
| $jg \quad Label$    | $jnle$ | $\sim (SF \oplus OF) \land \sim ZF$ | 有符号数，$>$   |
| $jge \quad Label$   | $jnl$  | $\sim (SF \oplus OF)$               | 有符号数，$\ge$ |
|                     |        |                                     |            |
| $jb \quad Label$    | $jnae$ | $CF$                                | 无符号数，$<$   |
| $jbe \quad Label$   | $jna$  | $CF \lor ZF$                        | 无符号数，$\le$ |
| $ja \quad Label$    | $jnbe$ | $\sim CF \land \sim ZF$             | 无符号数，$>$   |
| $jae \quad Label$   | $jnb$  | $\sim CF$                           | 无符号数，$\ge$ |
### 条件数据传送与条件控制转移
- 条件控制转移
	- 使用`jmp`类指令。根据条件跳转到不同位置，**改变程序执行流**。
- 条件数据传送
	- 根据条件，选择性执行赋值或传送，**不改变程序执行流**。
	- 对于简单条件，开启gcc优化后启用。
- 原因
	- 处理器通过流水线来获得高性能，遇到条件转移时会进行分支预测逻辑来猜测每条跳转指令是否会执行。错误的预测跳转会要求处理器丢弃流水线中剩余指令，然后使用正确的指令填充流水线。
	- 当每个条件分支中命令较短时，分支预测错误处罚就主导这个函数的性能。
	- 当每个条件分支命令很长时，因为条件数据传送会优先计算分支的值，因此会损失大量性能，此时更适合用条件数据传送。
	- 条件控制转移和条件数据传送相比更不依赖于数据。处理指针时若是使用条件数据传送则容易导致错误的指针引用。
#### 条件传送指令
| 指令           | 同义名      | 传送条件           | 描述       |
| ------------ | -------- | -------------- | -------- |
| `cmove S,R`  | `cmovz`  | `ZF`           | 相等/零     |
| `cmovne S,R` | `cmovnz` | `~ZF`          | 不等/非零    |
|              |          |                |          |
| `cmovs S,R`  |          | `SF`           | 负数       |
| `cmovns S,R` |          | `~SF`          | 非负数      |
|              |          |                |          |
| `cmovb S,R`  |          | `CF`           | 无符号$<$   |
| `cmovbe S,R` |          | CF\|ZF         | 无符号$\le$ |
| `cmova S,R`  |          | `~SF&~ZF`      | 无符号$>$   |
| `cmovae S,R` |          | `~CF`          | 无符号$\ge$ |
|              |          |                |          |
| `cmovl S,R`  |          | `SF^OF`        | 有符号$<$   |
| `cmovle S,R` |          | (SF^OF)\|ZF    | 有符号$\le$ |
| `cmovg S,R`  |          | `~(SF^OF)&~ZF` | 有符号$>$   |
| `cmovge S,R` |          | `~(SF^OF)`     | 有符号$\ge$ |
- 源操作数$S$可以为寄存器或内存地址。
- 目的操作数$R$只能为寄存器。
- 操作数的大小由目的寄存器决定。只支持16位、32位和64位长，不支持单字节的条件传送。
#### 分支预测的时间关系
- 执行代码的平均时间$T_{avg} (p)=(1 - p) T_{OK} + p(T_{OK} + T_{MP}) = T_{OK} + pT_{MP}$
	- 没有预测错误时的代码执行时间，$T_{OK}$
	- 预测错误的处罚，$T_{MP}$
- 预测错误时的代码执行时间$T_{ERR} = T_{OK} + T_{MP}$
### 编译器对循环的处理
``` C
// while循环的第一种,跳转到中间。
	goto TEST;
LOOP:
	body_statement;
TEST:
	if(test_expr)
		goto LOOP;
// while循环的第二种，guarded-do
	if(!test_expr)
		goto DONE;
LOOP:
	body_statement;
	if(test_expr)
		goto LOOP;
DONE:
// do-while循环
LOOP:
	body_statement;
	if(test_expr)
		goto LOOP;
```
## 分支
- `switch`根据一个整数索引值进行多重分支。使用跳转表来实现。
	- 跳转表是一个数组，表项`i`是一个代码段的地址，该代码段的实现的是当开关索引值等于`i`时执行的操作。
		- 开启ASLR后，**跳转表存的是相对偏移量，不是绝对地址**。
			- 相对偏移只需 4 字节，绝对地址在 64 位系统中需 8 字节。
				- GCC/Clang链接器会默认将代码段（.text）、跳转表（.rodata）等都链接到距离某条指令 **不超过$\pm2GB$的范围**。
				- 如果一个跳转表或函数太远，**编译器/链接器会调整布局**，或选择其他跳转策略（比如绝对地址，或中转跳转 thunk stub）。
				- ELF/PE/Mach-O 等格式都会控制各节段的位置。
				- 现代 x86-64 采用了 RIP-relative addressing（尤其启用 PIE 时），必须使用 4 字节相对偏移。
			- 跳转表中保存偏移，方便在任意内存位置执行。
			- 支持 ASLR 和共享库重定位。
	- 使用跳转表时，执行开关语句的时间与开关情况数量无关。
	- GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。
		- 当**开关语句较多**时(如4个以上)，并且**值的范围跨度较小**时，会使用跳转表。
			- 因为GCC处理跳转表时，是直接将最小条件作为0，直接按照分支的大小顺序进行索引的。
			- **索引号会转为无符号整型**。
		- GCC中使用`&&`表示指向代码位置的指针。`&`为指向数据的指针。
### GCC 处理switch
| 策略类型                     | 使用条件                 | 本质做法                      |
| ------------------------ | -------------------- | ------------------------- |
| **顺序比较链**                | case 少（一般 ≤3 个）      | 生成 if-else 样式的 `cmp + je` |
| **跳转表（jump table）**      | case 多且值分布密集（跨度小，稠密） | 用 case 值作为数组索引，跳转         |
| **二分查找树（binary search）** | case 多且值分布稀疏（跨度大）    | 使用 `cmp` 构造查找树跳转          |
- 在启用优化后（如 `-O2`），GCC 会自动对 `case` **排序并归一化**，保证跳转表逻辑正确：
	1. 按值排序，自动构建 `(x - min)` 的偏移。
	2. 构建 `.quad .Lcase1, .Lcase2, .Lcase3` 跳转数组
	3. 所以：**case 的编写顺序不会影响 jump table 是否生成，但可能影响 jump table 的排列顺序**