---
date: 2025-06-30
tags:
---
# 访问信息
- 一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器。
	- 用于存储整数数据和指针。
	- 通用目的寄存器
		- `RAX,RBX,RCX,RDX`
			- `EAX,EBX,ECX,EDX`
				- `AX,BX,CX,DX`
					- `AH,BH,CH,DH`
					- `AL,BL,CL,DL`
		- `RSI,RDI`
			- `ESI,EDI`
				- `SI,DI`
					- `SIH,DIH`
					- `SIL,DIL`
		- `RBP,RSP`
			- `EBP,ESP`
				- `BP,SP`
					- `BPH,SPH`
					- `BPL,SPL`
		- `R8,R9,R10,R11,R12,R13,R14,R15`
			- `R8D,R9D,R10D,R11D,R12D,R13D,R14D,R15D`
				- `R8W,R9W,R10W,R11W,R12W,R13W,R14W,R15W`
				- `R8B,R9B,R10B,R11B,R12B,R13B,R14B,R15B`
	- 函数调用传参顺序`RDI->RSI->RDX->RCX->R8->R9`，后续参数保存在栈上。
	- `RAX`存放返回值。
	- `R10,R11`由调用者保存。
	- `RBX,RBP,R12,R13,R14,R15`由被调用者保存。
- 复制和生成的指令以寄存器为目标是，对于生成小于8字节结果的指令。
	- 生成1字节和2字节数字的指令，会保持剩下的字节不变。
	- 生成4字节数字的指令会把高4字节置为0。
		- 用于从IA32扩展到x86-64。
- 将不同的指令划分为**指令类**。
	- 每一类指令中的指令执行相同的操作，只是操作数大小不同。
## 操作数指示符
- x86-64支持多种操作数格式。
	- **立即数**
		- 用于表示常数。
		- ATT格式的书写方式中是`$`后跟一个用C表示法表示的整数。
		- 不同的指令允许的立即数的数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
	- **寄存器**
		- 表示某个寄存器的值。
		- 用符号$r_a$来表示任意寄存器$a$。
		- 用$R[r_a]$来表示a寄存器的值。
	- **内存引用**
		- 根据计算出来的地址(有效地址)访问某个内存位置。
		- 用$M_b[Addr]$表示对存储在内存中从$Addr$开始的$b$个字节值的引用。
### 操作数格式与寻址方式
| 类型  | 格式               | 操作数值                               | 名称     |
| --- | ---------------- | ---------------------------------- | ------ |
| 立即数 | $\$Imm$          | $Imm$                              | 立即数寻址  |
| 寄存器 | $r_a$            | $R[r_a]$                           | 寄存器寻址  |
| 存储器 | $Imm$            | $M[Imm]$                           | 绝对寻址   |
| 存储器 | $(r_a)$          | $M[R[r_a]]$                        | 间接寻址   |
| 存储器 | $Imm(r_b)$       | $M[Imm + R[r_b]]$                  | 基址偏移寻址 |
| 存储器 | $(r_b,r_i)$      | $M[R[r_b]+R[r_i]]$                 | 变址寻址   |
| 存储器 | $Imm(r_b,r_i)$   | $M[Imm + R[r_b]+ R[r_i]]$          | 基址变址寻址 |
| 存储器 | $(,r_i,s)$       | $M[R[r_i] \cdot s]$                | 比例变址寻址 |
| 存储器 | $Imm(,r_i,s)$    | $M[Imm + R[r_i] \cdot s]$          | 比例变址寻址 |
| 存储器 | $(r_b,r_i,s)$    | $M[R[r_b] + R[r_i] \cdot s]$       | 比例变址寻址 |
| 存储器 | $Imm(r_b,r_i,s)$ | $M[Imm + R[r_b] + R[r_i] \cdot s]$ | 比例变址寻址 |
- **比例因子（scale）** **不能是寄存器，只能是常数常量(1,2,4,8)**。
### 特殊的寄存器
| 类型                | 是否可用                                      |
| ----------------- | ----------------------------------------- |
| 通用寄存器（RAX, RBX 等） | ✅ base/index 都行                           |
| `RSP`             | ✅ base，❌ index                            |
| `RBP`             | ✅ base（部分编码限制），可作为变址寄存器，但不推荐，容易混淆栈管理。     |
| `RIP`             | ✅ 仅用于 rip-relative，不可自由替代 base，不能作为基址或变址。 |
| 段寄存器              | ❌ 不可用于地址计算                                |
## 数据传送指令
- 传送指令的两个操作数不能都指向内存位置。
	- 在内存中的两个地址之间复制时，需要先将数据传入寄存器，再写入。
	- **寄存器部分的大小必须与指令类型的大小匹配**。
	- **立即数是指令中的数据，而不是内存中的数。x86-64允许将立即数直接写入内存。但GNU汇编器的汇编语法ATT不允许该写法**。
- 除`movl`以外的传送指令只会更新目的操作数指定的寄存器字节或内存位置。
	- `movl`会将目的操作数寄存器的高位4字节置0。
- 将较小的源值复制到较大的目的时，需使用零扩展数据传送或符号扩展数据传送。
### 数据传送指令的类型
| 指令                   | 效果          | 描述      |
| -------------------- | ----------- | ------- |
| $MOV \qquad S,D$     | $D \gets S$ | 传送      |
| $movb$               |             | 传送字节    |
| $movw$               |             | 传送字     |
| $movl$               |             | 传送双字    |
| $movq$               |             | 传送四字    |
| $movabsq \qquad I,R$ | $R \gets I$ | 传送绝对的四字 |
- 常规的`movq`只能以表示为32位补码的立即数作为源操作数，然后将这个值**符号扩展**得到64位的值，放到目的位置。
- `movabsq`能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的位置。
### 零扩展数据传送指令
| 指令                | 效果                      | 描述             |
| ----------------- | ----------------------- | -------------- |
| $MOVZ \qquad S,R$ | $R \gets \text{零扩展(S)}$ | 以零扩展进行传送       |
| `movzbw`          |                         | 将做了零扩展的字节传送到字  |
| `movzbl`          |                         | 将做了零扩展的字节传送到双字 |
| `movzbq`          |                         | 将做了零扩展的字节传送到四字 |
| `movzwl`          |                         | 将做了零扩展的字传送到双字  |
| `movzwq`          |                         | 将做了零扩展的字传送到四字  |
- 并没有将零扩展的双字传送到四字的指令，因为`movl`传送双字时，会将高4字节置0，效果相同。
### 符号扩展数据传送指令
| 指令                | 效果                               | 描述                   |
| ----------------- | -------------------------------- | -------------------- |
| $MOVS \qquad S,R$ | $R \gets \text{符号扩展(S)}$         | 传送符号扩展的二字节           |
| `movsbw`          |                                  | 将做了符号扩展的字节传送到字       |
| `movsbl`          |                                  | 将做了符号扩展的字节传送到双字      |
| `movsbq`          |                                  | 将做了符号扩展的字节传送到四字      |
| `movswl`          |                                  | 将做了符号扩展的字传送到双字       |
| `movswq`          |                                  | 将做了符号扩展的字传送到四字       |
| `movslq`          |                                  | 将做了符号扩展双字传送到四字       |
|                   |                                  |                      |
| `cltq`            | $\%rax \gets \text{符号扩展(\%eax)}$ | 把$\%eax$符号扩展到$\%rax$ |
- `cltq`没有参数，类似于`movslq %eax,%rax`
## 算数和逻辑操作
| 指令                | 效果                       | 描述             |
| ----------------- | ------------------------ | -------------- |
| $leaq \qquad S,D$ | $D \gets \& S$           | 加载有效地址         |
|                   |                          |                |
| $INC \qquad D$    | $D \gets D + 1$          | 加1             |
| $DEC \qquad D$    | $D \gets D - 1$          | 减1             |
|                   |                          |                |
| $NEG \qquad D$    | $D \gets -D$             | 取负             |
|                   |                          |                |
| $ADD \qquad S,D$  | $D \gets D + S$          | 加              |
| $ADC \qquad S,D$  | $D \gets D + (S + CF)$   | 进位加法           |
| $SUB \qquad S,D$  | $D \gets D - S$          | 减              |
| $SBB \qquad S,D$  | $D \gets D - (S + CF)$   | 借位减法           |
|                   |                          |                |
| $MUL \qquad D$    | $D \gets \%rax \times S$ | 无符号乘           |
| $IMUL \qquad S,D$ | $D \gets D \times S$     | 有符号乘           |
| $DIV \qquad S,D$  | $D \gets D \div S$       | 无符号除           |
| $IDIV \qquad S,D$ | $D \gets D \div S$       | 有符号除           |
|                   |                          |                |
| $NOT \qquad D$    | $D \gets \ \sim D$       | 取反             |
| $XOR \qquad S,D$  | $D \gets D \lor S$       | 或              |
| $OR \qquad S,D$   | $D \gets D \land S$      | 与              |
| $AND \qquad S,D$  | $D \gets D \oplus S$     | 异或             |
### 移位
| 指令               | 效果                 | 描述             |
| ---------------- | ------------------ | -------------- |
| $SHL \qquad k,D$ | $D \gets D << k$   | 逻辑左移(等同于$SAL$) |
| $SHR \qquad k,D$ | $D \gets D >>_L k$ | 逻辑右移，零扩展。      |
|                  |                    |                |
| $SAL \qquad k,D$ | $D \gets D << k$   | 算数左移           |
| $SAR \qquad k,D$ | $D \gets D >>_A k$ | 算数右移，符号扩展。     |
|                  |                    |                |
| $ROL \qquad k,D$ | $D \gets D <<< k$  | 循环左移           |
| $ROR \qquad k,D$ | $D \gets D >>> k$  | 循环右移           |
- 移位指令的偏移量只能使用%cl或立即数。
### 除数
| 操作数宽度 | 被除数 寄存器     | 商 存放 | 余数 存放 |
| ----- | ----------- | ---- | ----- |
| 8 位   | AX          | AL   | AH    |
| 16 位  | DX:AX （高：低） | AX   | DX    |
| 32 位  | EDX:EAX     | EAX  | EDX   |
| 64 位  | RDX:RAX     | RAX  | RDX   |
- 除法不管是有符号乘法还是无符号乘法都说单操作数。
### 乘法
| 操作数宽度 | 被乘数 / 乘数寄存器 | 结果高位寄存器 | 结果低位寄存器 |
| :---: | :---------: | :-----: | :-----: |
|  8 位  |     AL      |   AH    |   AL    |
| 16 位  |     AX      |   DX    |   AX    |
| 32 位  |     EAX     |   EDX   |   EAX   |
| 64 位  |     RAX     |   RDX   |   RAX   |
- 无符号乘法只有一种单操作数形式，另一个操作数是`%rax,%eax,%ax,%al`。
	- 对于低64位乘法，有符号乘法与无符号乘法效果相同。只是有符号乘法无法按照无符号乘法逻辑设置CF和OF。
		- 一般使用有符号乘法代替无符号乘法，有符号乘法更灵活。
- 有符号乘法有三种操作数形式，单操作数，双操作数和三操作数。
	- 只有单操作数时，才会保存高位和低位。
	- 双操作数和三操作数只会保存低位。
- **GCC/Clang 在实现 `signed __int128` 乘法时，并没有直接选择那条一元 `imul r/m64`**（它本身也能写出高半到 `RDX`），而是沿用了“无符号乘 → 手动符号修正”的多精度乘法框架。
	- 对其进行无符号乘法时，能自动存储高位和低位。
	- 进行有符号乘法时，只能使用无符号乘和手动符号修正来实现。
### 与8字相关的运算
| 指令               | 效果                                                  | 描述               |
| ---------------- | --------------------------------------------------- | ---------------- |
| $imulq \qquad S$ | $R[\% rdx]: R[\% rax] \gets S \times R[\% rax]$     | 有符号全乘法           |
| $mulq \qquad S$  | $R[\% rdx]: R[\% rax] \gets S \times R[\% rax]$     | 无符号全乘法           |
| $idivq \qquad S$ | $R[\% rdx] \gets R[\% rdx]: R[\% rax] \  \%  \ S$   | 有符号除法            |
|                  | $R[\% rax] \gets R[\% rdx]: R[\% rax] \  \div  \ S$ |                  |
| $divq \qquad S$  | $R[\% rdx] \gets R[\% rdx]: R[\% rax] \  \%  \ S$   | 无符号除法            |
|                  | $R[\% rax] \gets R[\% rdx]: R[\% rax] \  \div  \ S$ |                  |
|                  |                                                     |                  |
| $cqto$           | $R[\% rdx]: R[\%rax] \gets \text{符号扩展} (R[\% rax])$ | 将$\%rax$符号扩展为8字。 |
- 两个4字相乘需要8字存储。会将%rdx和%rax组成128位用于存储。
	- 存储时，rdx存高位，rax存低位。
	- 除法中，rdx存余数，rax存商。
## 按位符号拓展
| 机器码     | AT&T 名称 | Intel 名称 | 效果                                                   | 描述       |
| ------- | ------- | -------- | ---------------------------------------------------- | -------- |
| `98`    | `cwtl`  | `CBW`    | $R[\%ax] \gets \text{符号扩展} (R[\% al])$               | 字节扩展为字。  |
| `66 98` | `cbtw`  | `CWDE`   | $R[\%eax] \gets \text{符号扩展} (R[\% ax])$              | 字扩展为双字。  |
| `48 98` | `cltq`  | `CDQE`   | $R[\%rax] \gets \text{符号扩展} (R[\% eax])$             | 双字扩展为四字。 |
| `99`    | `cltd`  | `CDQ`    | $R[\% edx]: R[\% eax] \gets \text{符号扩展} (R[\% eax])$ | 双字扩展为四字。 |
| `66 99` | `cwtd`  | `CWD`    | $R[\% dx]: R[\% ax] \gets \text{符号扩展} (R[\% ax])$    | 字扩展为双字。  |
| `48 99` | `cqto`  | `CQO`    | $R[\% rdx]: R[\%rax] \gets \text{符号扩展} (R[\% rax])$  | 四字扩展为八字。 |
- 0x66会将操作数切到16位(字)。
- 0x48会将操作数切到64位(四字)。

## 加载有效地址
- `lea`是`movq`指令的变形。目的操作数必须是一个寄存器。
- 并不读入数据，而是将有效地址写入到目的操作数中。
