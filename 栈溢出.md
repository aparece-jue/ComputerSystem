---
date: 2025-07-04
tags:
---
# 栈溢出
- 栈溢出攻击中，插入攻击代码时不仅需要插入代码还需要插入指向这段代码的指针。
	- 该指针是攻击字符串的一部分，产生这个指针需要知道这个字符串放置的栈地址。
- 不开启栈随机化时，在不同的机器中，栈的位置相当固定，从而导致许多系统都容易受到同一种病毒的攻击，该现象称为**安全单一化**。
	- 栈随机化是使栈的位置在程序每次运行时都有变化。
		- 实现方式是程序开始时，在栈上随机分配一段0-n字节之间的随机大小的空间。
			- 如使用`alloca`在栈上分配指定字节数量的空间。
			- 程序不使用这段空间，但是该空间会使程序每次执行时后续栈的位置出现变化。
		- 分配的范围n有一定限度，要在不浪费程序太多空间的前提下，获得足够多的栈地址变化。
## 防护措施
### 地址空间布局随机化(ASLR)
- ASLR在每次运行时，会将程序代码(`.text`仅在开启`PIE`选项后才会随机化)、库代码(`libc`等)、栈(`static`)、全局变量(`.data`,`.bss`仅在开启`PIE`选项后才会随机化)、堆数据(`heap`)和mmap 区域（如匿名映射、JIT代码等，常用于共享库、栈保护页、堆、JIT 等。）加载到内存的不同区域。
- 每个部分的随机化都采用独立的偏移。
- 以段为整体以页为单位进行随机化。
	- **一个段由多个页组成**，但**一个页只属于一个段**。
	- 每个段内的相对偏移都并未改变。
- **即使程序启用了 PIE，如果操作系统未启用 ASLR，程序的代码段和数据段也不会被随机化**，它们会被加载到一个固定的基地址。
	- **PIE**只是让程序的代码段和数据段拥有了可被随机化加载的能力。
- 是系统级安全防护。级别通过`/proc/sys/kernel/randomize_va_space`控制。
	- 为`0`时，关闭。
	- 为`1`时，仅栈、mmap、共享库地址随机化（代码段不随机，适用于非PIE）。
	- 为`2`时，包括栈、堆、mmap、共享库、VDSO 都进行地址随机化，配合 PIE 才能让程序代码段（text）随机化。
#### NOP滑梯
- 通过在实际的攻击代码前插入很长的一段`NOP`指令，使程序顺序执行。
	- 只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。
### 栈破坏检测(canary)
- GCC在产生的代码中加入了栈保护者(stack protector)机制。
	- 在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的(canary)值。也成为**哨兵值**(guard value)。
	- 该值在程序每次运行时随机产生。**在恢复寄存器状态和从函数返回前，程序检查这个值是否被该函数的某个操作或该函数调用的某个函数所改变**，若改变则程序异常终止。
``` x86asm
func:
subq $24,%rsp
movq %fs:0x28,%rax
movq%rax,8(%rsp)
;...
movq 8(%rsp), %rax        ; 取出栈上的 canary
xorq %fs:40, %rax         ; 与原始 canary 比较（或直接比较是否相等）
jne  call __stack_chk_fail; 不相等就说明被篡改
addq $24,%rsp
ret
```
- 用段寻址从内存中读取一个值，将其放入紧挨着保存rbp的位置。
	- **`%fs:0x28`（十进制 40）** 是 **线程本地存储（TLS）中存储的 canary 值**；
	- 该值由 glibc 的 `__stack_chk_guard` 全局变量控制，在每个线程启动时由内核随机生成；
- GCC只在函数中有局部`char`类型缓冲区时才会插入这样的代码。
- 开启后会对栈数据进行重排，使缓冲区字符串更接近canary，使其溢出后不会破坏局部变量。
### 限制可执行代码区域
- 限制在哪些内存区域中能够存放可执行代码。
	- 正常程序中，只有保存程序代码段的内存才需要可执行权。其他部分可被限制为只允许读写。
- 虚拟内存空间在逻辑上被分为了**页**，页的大小一般为`2KB`或`4KB`。
- 早期的x86体系结构将读和执行访问控制合并为一个1位标志。
	- 导致被标记为可读的页都是可执行的。
	- 栈必须是既可读又可写的，因此栈上的字节都是可执行的。
	- 可通过部分机制实现可读但不可执行，但会带来严重的性能损失。
- 现在的AMD和Intel为64位处理器的内存保护引入了**NX(No-Execute,不执行)** 位，将读和执行访问模式分开。
	- 通过**NX**位可将栈标记为可读可写不可执行。检查页是否可执行由硬件来完成，效率上没有损失。
- 有些类型的程序要求动态产生和执行代码的能力。
	- 即时编译技术为解释语言编写的程序动态地产生代码，以提高执行性能。
	- 能否将可执行代码限制在编译器在创建时产生的那个部分中，取决于语言和操作系统。
## 变长栈帧
- 对于大多数代码，编译器能够预先确定需要为栈帧分配多少空间。