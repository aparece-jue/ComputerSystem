# 程序的机器级表示
## 程序编码
1. **C预处理器**扩展源代码，插入所有用`#include`命令指定的文件，并展开用`#define`指定的宏。
2. **编译器**生成源文件的汇编代码。
3. **汇编器**将汇编代码转化成二进制目标代码文件。
	- **目标代码**是机器代码的一种形式，**包含所有指令的二进制表示，但还未填入全局值的地址**。
4. 链接器将生成的目标代码文件与实现库函数的代码合并，生成最终的可执行代码文件。
	- 可执行代码是处理器执行的代码格式。
	- 链接器将目标代码的地址移动一段不同的地址范围中。并填充`callq`等指令的调用函数需要的地址。为函数调用找到匹配的函数的可执行代码的位置。
## 机器级编码
- 使用了两种抽象来隐藏实现细节。
	- 由**指令集体系结构或指令集架构(Instruction Set Architecture,ISA)** 定义机器级程序的格式和行为。
		- ISA定义了处理器状态、指令的格式，以及每条指令对状态的影响。
	- 机器级程序使用的内存地址是虚拟地址，提供的内存模型实际是将多个硬件存储器和操作系统软件组合形成的。
### x86-64的机器代码与C代码的差别。
- 部分处理器状态，通常对C代码隐藏。
	- 程序计数器(PC)，x86-64中的(RIP)。
		- 给出要执行的下一条指令在内存中的位置。
	- 整数寄存器文件的十六个命名位置。
		- 记录某些重要的程序状态和保存临时数据等。
	- 条件码寄存器。
		- 保存最近执行的算数和逻辑指令的状态信息。
	- 一组向量寄存器。
		- 可存放一个或多个整数或浮点数。
- 机器代码只是单纯地将内存看作一个很大的，按字节寻址的数组。
- 程序的内存信息
	- 程序的内存地址的高16位地址必须设置为0，因此一个地址实际上能够指定的是$2^{48}$或64TB范围内的一个字节。
	- 包括
		- 程序的可执行机器代码。
		- 操作系统需要的一些信息。
		- 用于管理过程调用和返回的运行时栈。
		- 用户分配的内存块。
### 机器代码与反汇编的特性
- x86-64属于CISC架构，指令长度从1到15个字节不等。
	- 常用的指令及操作数较少的指令所需字节数少，其余的所需字节数较多。
- 设计指令格式的方式是从某个指定位置(前缀)开始，将字节唯一地解码成机器指令。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码的。不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有细微差别。
	- 反汇编器生成的代码省略了很多指令结尾的`q`。
		- 这些后缀是大小指示符，在大多数情况中可以省略。
		- 有的反汇编器会给`call`和`ret`后加`q`。
### 在C语言中插入汇编代码的方法
1. 用汇编代码编写整个函数，用汇编器和链接器将其与C语言代码合并。
2. 利用GCC的内联汇编，直接在C程序中嵌入汇编代码。
	- 使用`asm`伪指令可以在C程序中包含简短的汇编代码，减少了与机器相关的代码量。
### ATT与Intel汇编代码格式
- objdump和gcc等工具默认使用ATT格式。
- ida默认使用Intel格式。
- 区别
	- Intel代码省略了指示大小的后缀。
	- Intel代码省略了寄存器名称前面的`%`符号。
	- **Intel代码用不同的方式来描述内存中的位置。**
	- 在带有多个操作数的指令情况下，列出操作数的顺序相反。
		- Intel的目的操作数在前，源操作数在后。
		- ATT的目的操作数在后，源操作数在前。
## 数据格式
- 2字节称为1个字。
### x86-64中C语言数据类型的大小
| C声明      | Intel 数据类型 | 汇编代码后缀 | 大小(字节) |
| -------- | ---------- | ------ | ------ |
| `char`   | 字节         | `b`    | 1      |
| `short`  | 字          | `w`    | 2      |
| `int`    | 双字         | `l`    | 3      |
| `long`   | 四字         | `q`    | 8      |
| `char *` | 四字         | `q`    | 8      |
| `float`  | 单精度        | `s`    | 4      |
| `double` | 双精度        | `l`    | 8      |
- 汇编代码的后缀用于表明操作数的大小，分别使用对应的汇编指令。
		- 如`mov`有`movb`、`movw`、`movl`、`movq`
- 因为浮点数使用的是一组完全不同的指令和寄存器，因此汇编指令也使用后缀`l`来表示双字整型和双精度浮点数。
