---
date: 2025-07-06
tags:
---
# 浮点代码
## 浮点体系结构
- 影响浮点数据操作的程序如何被映射到机器上。
	- 如何存储和访问浮点数。
		- 通常是通过某种寄存器完成。
	- 对浮点数据操作的指令。
	- 向函数传递浮点数参数和从函数返回浮点数结果的规则。
	- 函数调用过程中保存寄存器的规则。
		- 调用者保存寄存器和被调用者保存寄存器。
- 图形和图像处理的**媒体**指令。
	- 允许多个操作以并行模式执行，称为单指令多数据(SIMD)。
	- 对多个不同的数据并行执行同一个操作。
	- 浮点体系结构扩展，用于管理寄存器组中的数据。
		- MMX(SIMD)->SSE->AVX
			- MMX的**MM寄存器**。64位(8字节)。
			- SSE的**XMM寄存器**。128位(16字节)。
			- AVX的**YMM寄存器**。256位(32字节)。
- SSE2中，媒体指令开始包括对标量浮点数据进行操作的指令，使用XMM或YMM寄存器的低32位或64位中的单个值。
	- 该标量模式提供一组寄存器和指令类似于其他处理器支持浮点数的形式。
	- 能够执行x86-64代码的处理器都支持SSE2或更高的版本。
		- x86-64浮点数是基于SSE或AVX的，包括传递过程参数和返回值的规则。
- AVX2
	- GCC给定`-mavx2`时，会生成AVX2代码。
	- GCC编译浮点程序时出现的指令大部分是标量AVX指令。
	- AVX浮点体系结构允许数据存储在16个YMM寄存器中，名称为`%ymm0`\~`%ymm15`。
		- 每个YMM寄存器都是256位(32字节)。
		- 当对标量数据操作时，这些寄存器只保存浮点数，且只使用低32位(float)或低64位(double)。
		- 汇编代码用寄存器的SSE XMM寄存器`%xmm0`\~`%xmm15`来引用他们。
			- 每个XMM寄存器都是对应的YMM寄存器的低128位。
### 媒体寄存器
| 256位寄存器 | 低128位寄存器 | 作用          |
| ------- | -------- | ----------- |
| %ymm0   | %xmm0    | 第1个FP参数，返回值 |
| %ymm1   | %xmm1    | 第2个FP参数     |
| %ymm2   | %xmm2    | 第3个FP参数     |
| %ymm3   | %xmm3    | 第4个FP参数     |
| %ymm4   | %xmm4    | 第5个FP参数     |
| %ymm5   | %xmm5    | 第6个FP参数     |
| %ymm6   | %xmm6    | 第7个FP参数     |
| %ymm7   | %xmm7    | 第8个FP参数     |
| %ymm8   | %xmm8    | 调用者保存       |
| %ymm9   | %xmm9    | 调用者保存       |
| %ymm10  | %xmm10   | 调用者保存       |
| %ymm11  | %xmm11   | 调用者保存       |
| %ymm12  | %xmm12   | 调用者保存       |
| %ymm13  | %xmm13   | 调用者保存       |
| %ymm14  | %xmm14   | 调用者保存       |
| %ymm15  | %xmm15   | 调用者保存       |
### 浮点传送和转换操作
#### 浮点传送指令
| 指令         | 源          | 目的       | 描述                                                             |
| ---------- | ---------- | -------- | -------------------------------------------------------------- |
| `vmovss`   | $M_{32}$   | $X$      | 传送单精度浮点数                                                       |
| `vmovss`   | $X$        | $M_{32}$ | 传送双精度浮点数                                                       |
| `vmovsd`   | $M_{64}$   | $X$      | 传送双精度浮点数                                                       |
| `vmovsd`   | $X$        | $M_{64}$ | 传送双精度浮点数                                                       |
| `vmovaps`  | $X$        | $X$      | 传送对齐的封装好的单精度浮点数                                                |
| `vmovapd`  | $X$        | $X$      | 传送对齐的封装好的双精度浮点数                                                |
|            |            |          |                                                                |
| `vmovddup` | $X/M_{64}$ | $X$      | **从源操作数中提取低位的一个或多个 double 精度浮点数，然后复制（duplicate）到目标寄存器的所有元素中**。 |
- 在内存和寄存器之间以及一对寄存器之间传送值。
	- $X$: XMM寄存器
	- $M_{32}$: 32位内存范围。
	- $M_{64}$: 64位内存范围。
- 引用内存的指令是**标量指令**。
	- 只对单个而不是一组封装好的数据值进行操作。
	- 只操作寄存器的**最低位元素（lower element）**，其余位保持不变或被忽略。
- 对齐与否都能正确执行。
	- 代码优化规则建议32位内存数据满足4字节对齐，64位内存数据满足8字节对齐。
- 内存引用的指定方式和整数`mov`指令一样，包括所有的寻址方式。
- `vmovaps`和`vmovapd`传值时，复制整个寄存器和只复制标量数据两者相比没有实质区别。
	- `a`表示16字节对齐，当用于读写内存是，若内存不满足16字节对齐则会导致异常。
#### 双操作数浮点转换指令
| 指令            | 源           | 目的         | 描述                                                   |
| ------------- | ----------- | ---------- | ---------------------------------------------------- |
| `vcvttss2si`  | $X/M_{32}$  | $R_{32}$   | 用截断的方法把单精度浮点数转换成整数                                   |
| `vcvttsd2si`  | $X/M_{64}$  | $R_{32}$   | 用截断的方法把双精度浮点数转换成整数                                   |
| `vcvttss2siq` | $X/M_{32}$  | $R_{64}$   | 用截断的方法把单精度浮点数转换成四字整数                                 |
| `vcvttsd2siq` | $X/M_{64}$  | $R_{64}$   | 用截断的方法把双精度浮点数转换成四字整数                                 |
|               |             |            |                                                      |
| `vcvtps2pd`   | $X/M_{128}$ | $X$        | 将**一组float值(至少包含2或4个)** 转换为 **double（双精度浮点）**，逐元素转换。 |
- 这些是对单个数据值进行操作的标量指令。把一个从XMM寄存器或内存中读出的浮点值进行转换，并将结果写入到一个通用寄存器中。
	- $X$: XMM寄存器
	- $M_{32}$: 32位内存范围。
	- $M_{64}$: 64位内存范围。
	- $R_{32}$: 32位通用寄存器。
	- $R_{64}$: 64位通用寄存器。
- 截断为向零舍入。
#### 三操作数浮点转换指令
| 指令           | 源1              | 源2            | 目的  | 描述                                                        |
| ------------ | --------------- | ------------- | --- | --------------------------------------------------------- |
| `vcvtsi2ss`  | $M_{32}/R_{32}$ | $X$           | $X$ | 把整数转换成单精度浮点数                                              |
| `vcvtsi2sd`  | $M_{32}/R_{32}$ | $X$           | $X$ | 把整数转换成双精度浮点数                                              |
| `vcvtsi2ssq` | $M_{64}/R_{64}$ | $X$           | $X$ | 把四字整数转换成单精度浮点数                                            |
| `vcvtsi2sdq` | $M_{64}/R_{64}$ | $X$           | $X$ | 把四字整数转换成双精度浮点数                                            |
|              |                 |               |     |                                                           |
| `vcvtss2sd`  | $M_{32}/R_{32}$ | $X$           | $X$ | 将单精度浮点数转换为双精度浮点数                                          |
| `vcvtsd2ss`  | $M_{64}/R_{64}$ | $X$           | $X$ | 将双精度浮点数转换为单精度浮点数                                          |
|              |                 |               |     |                                                           |
| `vunpcklps`  | $X$             | $X / M_{128}$ | $X$ | 从两个 packed float 向量中提取低位（前两个）元素，交叉打包成新的向量。                |
|              |                 |               |     |                                                           |
| `vcvtpd2ss`  | $X$             | $X / M_{128}$ | $X$ | 将 packed double 精度浮点数转换为标量 float。将每组的double转换为float后存在低位。 |
- 将第一个源的数据类型转换为目的数据类型。
- 源1操作数读取自内存或通用目的寄存器。
- 源2操作数只影响源1操作数以外的剩余字节。用于非破坏性写入。
	- 常用情况下源2与目的操作数相同。
- 目的操作数必须是XMM寄存器。
- `vunpcklps src1,src2,dst`
	- `src1`: `[s3,s2,s1,s0]`
	- `src2`: `[d3,d2,d1,d0]`
	- `dst`: `[d1,s1,d0,s0]`
- `vcvtpd2ss`
	- `src1`: `[s1.h,s1.l,s0.h,s0.l]`
	- `src2`: `[d3,d2,d1,d0]`
	- `dst`: `[d3,d2,s1.f,s0.f]`
### 浮点运算操作
#### 标量浮点算术运算
| 单精度      | 双精度      | 效果                                   | 描述     |
| -------- | -------- | ------------------------------------ | ------ |
| `vaddss` | `vaddsd` | $D \gets S_2 + S_1$                  | 浮点数加   |
| `vsubss` | `vsubsd` | $D \gets S_2 - S_1$                  | 浮点数减   |
| `vmulss` | `vmulsd` | $D \gets S_2 \times S_1$             | 浮点数乘   |
| `vdivss` | `vdivsd` | $D \gets S_2 \div S_1$               | 浮点数除   |
| `vmaxss` | `vmaxsd` | $D \gets \text{max} \{ S_2 , S_1 \}$ | 浮点数最大值 |
| `vminss` | `vminsd` | $D \gets \text{min} \{ S_2 + S_1 \}$ | 浮点数最小是 |
| `sqrtss` | `sqrtsd` | $D \gets \sqrt{S_1}$                 | 浮点数平方根 |
- $S1$可以为XMM寄存器或一个内存位置。
- $S2$和$D$都必须是XMM寄存器。
- AVX浮点操作不能以立即数作为操作数。
	- 编译器必须为所有的常量值分配和初始化存储空间，然后代码将该值从内存导入。
#### 对封装数据的位级运算
| 单精度       | 双精度       | 效果                                        | 描述        |
| --------- | --------- | ----------------------------------------- | --------- |
| `vxorrps` | `vxorpd`  | $D \gets S_2 \oplus S_1$                  | 位级异或      |
| `vandps`  | `vandpd`  | $D \gets S_2 \land S_1$                   | 位级与       |
| `vorps`   | `vorpd`   | $D \gets S_2 \lor S_1$                    | 位级或       |
| `vandnps` | `vandnpd` | $D \gets (\textasciitilde S_2) \land S_1$ | 位级与非(反掩码) |
- 作用于封装好的数据。会更新整个目的XMM寄存器，对两个源操作数的所有位都实施指定的位级操作。
#### 浮点数比较
| 指令              | 基于          | 描述       |
| --------------- | ----------- | -------- |
| `ucomiss S1,S2` | $S_2 - S_1$ | 比较单精度浮点数 |
| `ucomisd S1,S2` | $S_2 - S_1$ | 比较双精度浮点数 |
- 类似于`CMP`指令。
	- $S_1$可为XMM寄存器或内存。
	- $S_2$必须为XMM寄存器。
- 会设置三个条件码。
	- 零标志位，`ZF`。
	- 进位标志位，`CF`。
	- 奇偶标志位，`PF`。
		- **当两个操作数中任意一个为`NaN`时，会设置该位**。
		- C语言中，若有参数位`NaN`，则认为比较失败。
			- 此时`x==x`的值为0。
##### 比较结果
| 顺序 $S_2$:$S_1$  | `CF` | `ZF` | `PF` |
| --------------- | ---- | ---- | ---- |
| **无序**(出现`NaN`) | 1    | 1    | 1    |
| $S_2 < S_1$     | 1    | 0    | 0    |
| $S_2 = S_1$     | 0    | 1    | 0    |
| $S_2 > S_1$     | 0    | 0    | 0    |
## 浮点数传参
- XMM寄存器`%xmm0`~`%xmm7`最多可以传递8个浮点参数。
	- 按照参数列出的顺序使用寄存器。
	- 可通过栈传递额外的浮点参数。
- 函数使用`%xmm0`来返回浮点值。
- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中的任意一个。
- 当函数包含指针、整数和浮点数混合的参数时。
	- 指针和整数通过通用寄存器传递。
	- 浮点值通过XMM寄存器传递。
	- 参数到寄存器的映射取决于他们的类型和排列顺序。
## AVX指令结构
- `vcvt<源类型><目标类型>`
	- `ps` = packed single,向量单浮点数
	- `pd` = packed double,向量双浮点数
	- `ss` = scalar single,标量单浮点数
	- `sd` = scalar double,标量双浮点数
	- `si` = int32,双字整数
	- `sdq` = int64(用于扩展),四字整数
	- `tt` = truncate（如 vcvttss2si 表示带截断）